import { Context, TransactionQueue } from "../internal";
import { ProcedureAuthorizationStatus, ProcedureOpts } from "../types";
import { AddBatchTransactionArgs, AddTransactionArgs, MaybePostTransactionValue, PostTransactionValueArray, ProcedureAuthorization } from "../types/internal";
/**
 * @hidden
 *
 * Represents an operation performed on the Polymesh blockchain.
 * A Procedure can be prepared to yield a {@link TransactionQueue} that can be run
 */
export declare class Procedure<Args = void, ReturnValue = void, Storage = Record<string, unknown>> {
    private prepareTransactions;
    private getAuthorization;
    private prepareStorage;
    private transactions;
    private _storage;
    private _context;
    /**
     * @hidden
     *
     * @param prepareTransactions - function that prepares the transaction queue
     * @param getAuthorization - can be a ProcedureAuthorization object or a function that returns a ProcedureAuthorization object
     */
    constructor(prepareTransactions: (this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<MaybePostTransactionValue<ReturnValue>>, getAuthorization?: ProcedureAuthorization | ((this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<ProcedureAuthorization> | ProcedureAuthorization), prepareStorage?: (this: Procedure<Args, ReturnValue, Storage>, args: Args) => Promise<Storage> | Storage);
    /**
     * @hidden
     * Set the context and storage (if not already set), return the Context
     */
    private setup;
    /**
     * @hidden
     * Reset the procedure
     */
    private cleanup;
    /**
     * @hidden
     */
    private _checkAuthorization;
    /**
     * Check if the current user has sufficient authorization to run the procedure
     *
     * @param args - procedure arguments
     */
    checkAuthorization(args: Args, context: Context, opts?: ProcedureOpts): Promise<ProcedureAuthorizationStatus>;
    /**
     * Build a {@link TransactionQueue} that can be run
     *
     * @param args.args - arguments required to prepare the queue
     * @param args.transformer - optional function that transforms the Procedure result
     * @param context - context in which the resulting queue will run
     * @param opts.signer - address that will be used as a signer for this procedure
     */
    prepare<QueueReturnType>(args: {
        args: Args;
        transformer?: (value: ReturnValue) => QueueReturnType | Promise<QueueReturnType>;
    }, context: Context, opts?: ProcedureOpts): Promise<TransactionQueue<ReturnValue, QueueReturnType>>;
    /**
     * Appends a transaction into this Procedure's queue. This defines
     *   what will be run by the TransactionQueue when it is started
     *
     * @returns an array of {@link PostTransactionValue}. Each element corresponds to whatever is returned by one of the resolver functions passed as options
     */
    addTransaction<TxArgs extends unknown[] | [], Values extends unknown[] = []>(args: AddTransactionArgs<TxArgs, Values>): PostTransactionValueArray<Values>;
    /**
     * Appends a Procedure into this Procedure's queue. This defines
     *   what will be run by the TransactionQueue when it is started
     *
     * @param proc - a Procedure that will be run as part of this Procedure's Transaction Queue
     * @param args - arguments to be passed to the procedure
     *
     * @returns whichever value is returned by the passed Procedure
     */
    addProcedure<ProcArgs, R, S>(procedure: Procedure<ProcArgs, R, S>, args: ProcArgs): Promise<MaybePostTransactionValue<R>>;
    addProcedure<R, S>(procedure: Procedure<void, R, S>): Promise<MaybePostTransactionValue<R>>;
    /**
     * Appends a batch of transactions into this Procedure's queue. This defines
     *   what will be run by the TransactionQueue when it is started
     *
     * @returns an array of {@link PostTransactionValue}. Each element corresponds to whatever is returned by one of the resolver functions passed as options
     */
    addBatchTransaction<ArgsArray extends (unknown[] | [])[], Values extends unknown[] = []>(args: AddBatchTransactionArgs<Values, ArgsArray>): PostTransactionValueArray<Values>;
    /**
     * internal data container. Used to store common fetched/processed data that is
     *   used by both `prepareTransactions` and `checkAuthorization`
     */
    get storage(): Storage;
    /**
     * contains the data services, signing Account, etc. In short, the *context* in which
     *   the Procedure is being run
     */
    get context(): Context;
}
//# sourceMappingURL=Procedure.d.ts.map