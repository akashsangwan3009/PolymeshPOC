import { Context, PolymeshError, PolymeshTransactionBase } from "../internal";
import { FeesBreakdown, TransactionQueueStatus } from "../types";
import { MaybePostTransactionValue } from "../types/internal";
/**
 * @hidden
 */
declare type PolymeshTransactionArray<TransactionArgs extends unknown[][]> = {
    [K in keyof TransactionArgs]: TransactionArgs[K] extends TransactionArgs[number] ? PolymeshTransactionBase<TransactionArgs[K]> : never;
};
/**
 * Class to manage procedural transaction queues
 */
export declare class TransactionQueue<ProcedureReturnType = void, ReturnType = ProcedureReturnType, TransactionArgs extends unknown[][] = unknown[][]> {
    /**
     * transactions that will be run in the queue
     */
    transactions: PolymeshTransactionArray<TransactionArgs>;
    /**
     * status of the queue
     */
    status: TransactionQueueStatus;
    /**
     * optional error information
     */
    error?: PolymeshError;
    /**
     * @hidden
     * internal queue of transactions to be run
     */
    private queue;
    /**
     * @hidden
     * value
     */
    private procedureResult;
    /**
     * @hidden
     * function that transforms the return type
     */
    private transformer;
    /**
     * @hidden
     * internal event emitter to listen for status changes
     */
    private emitter;
    /**
     * @hidden
     * whether the queue has run or not (prevents re-running)
     */
    private hasRun;
    private context;
    /**
     * Create a transaction queue
     *
     * @param args.transactions - list of transactions to be run in this queue
     * @param args.procedureResult - value that will be returned by the queue after it is run. It can be a {@link PostTransactionValue}
     * @param args.transformer - function that transforms the procedure's return value before returning it after the queue is run
     */
    constructor(args: {
        transactions: PolymeshTransactionArray<TransactionArgs>;
        procedureResult: MaybePostTransactionValue<ProcedureReturnType>;
        transformer?: (result: ProcedureReturnType) => Promise<ReturnType> | ReturnType;
    }, context: Context);
    /**
     * Run the transactions in the queue in sequential order. If a transaction fails or the user refuses to sign it, one of two things can happen:
     *
     * 1) If `transaction.isCritical === true`, the entire queue fails and the corresponding error is stored in `this.error` as well as thrown
     * 2) Otherwise, the queue continues executing and the error is stored in `transaction.error`
     */
    run(): Promise<ReturnType>;
    /**
     * Retrieve a lower bound of the fees required to execute this transaction queue.
     *   Transaction fees can be higher at execution time for three reasons:
     *
     * - One or more transaction arguments depend on the result of another transaction in the queue.
     *   This means fees can't be calculated for said transaction until previous transactions in the queue have run
     * - Protocol or gas fees may vary between when this value is fetched and when the transaction is actually executed because of a
     *   governance vote
     *
     * Transaction fees are broken down between those that have to be paid by the signing Account and
     *   those that will be paid by third parties. In most cases, the entirety of the fees will be paid by
     *   either the signing Account or a **single** third party Account
     */
    getMinFees(): Promise<FeesBreakdown>;
    /**
     * @hidden
     *
     * Return a breakdown of the queue's fees and which transactions are being subsidized
     */
    private _getMinFees;
    /**
     * Subscribe to status changes on the Transaction Queue
     *
     * @param listener - callback function that will be called whenever the Transaction Queue's status changes
     *
     * @returns unsubscribe function
     */
    onStatusChange(listener: (transactionQueue: this, err?: PolymeshError) => void): () => void;
    /**
     * Subscribe to status changes on individual transactions
     *
     * @param listener - callback function that will be called whenever the individual transaction's status changes
     *
     * @returns unsubscribe function
     */
    onTransactionStatusChange<Values extends unknown[]>(listener: (transaction: PolymeshTransactionBase<Values>, transactionQueue: this) => void): () => void;
    /**
     * Subscribe to the results of this queue being processed by the harvester (and as such, available to the middleware)
     *
     * @param listener - callback function that will be called whenever the middleware is updated with the latest data.
     *   If there is an error (timeout or middleware offline) it will be passed to this callback
     *
     * @note this event will be fired even if the queue fails
     * @returns unsubscribe function
     * @throws if the middleware wasn't enabled when instantiating the SDK client
     */
    onProcessedByMiddleware(listener: (err?: PolymeshError) => void): () => void;
    /**
     * @hidden
     */
    private updateStatus;
    /**
     * @hidden
     */
    private executeTransactionQueue;
    /**
     * Poll the middleware every 2 seconds to see if it has already processed the
     *   block that reflects the changes brought on by this queue being run. If so,
     *   emit the corresponding event. After 5 retries (or if the middleware can't be reached),
     *   the event is emitted with an error
     *
     * @note uses the middleware
     */
    private emitWhenMiddlewareIsSynced;
    /**
     * Check if balances and allowances (both third party and signing Account)
     *   are sufficient to cover this queue's fees
     */
    private assertFeesCovered;
}
export {};
//# sourceMappingURL=TransactionQueue.d.ts.map