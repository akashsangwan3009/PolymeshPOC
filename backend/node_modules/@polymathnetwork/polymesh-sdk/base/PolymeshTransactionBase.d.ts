/// <reference types="node" />
import { SubmittableExtrinsic } from '@polkadot/api/types';
import { DispatchError } from '@polkadot/types/interfaces';
import { ISubmittableResult, Signer as PolkadotSigner } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { EventEmitter } from 'events';
import { Context, Identity, PolymeshError } from "../internal";
import { Fees, PayingAccount, TransactionStatus } from "../types";
import { BaseTransactionSpec, PostTransactionValueArray } from "../types/internal";
/**
 * Wrapper class for a Polymesh Transaction
 */
export declare abstract class PolymeshTransactionBase<Values extends unknown[] = unknown[]> {
    /**
     * current status of the transaction
     */
    status: TransactionStatus;
    /**
     * stores errors thrown while running the transaction (status: `Failed`, `Aborted`)
     */
    error?: PolymeshError;
    /**
     * stores the transaction receipt (if successful)
     */
    receipt?: ISubmittableResult;
    /**
     * transaction hash (status: `Running`, `Succeeded`, `Failed`)
     */
    txHash?: string;
    /**
     * hash of the block where this transaction resides (status: `Succeeded`, `Failed`)
     */
    blockHash?: string;
    /**
     * number of the block where this transaction resides (status: `Succeeded`, `Failed`)
     */
    blockNumber?: BigNumber;
    /**
     * whether this transaction failing makes the entire transaction queue fail or not
     */
    isCritical: boolean;
    /**
     * @hidden
     *
     * Identity that will pay for this transaction's fees. This value overrides any subsidy,
     *   and is seen as having infinite allowance (but still constrained by its current balance)
     */
    protected paidForBy?: Identity;
    /**
     * @hidden
     *
     * wrappers for values that will exist after this transaction has executed
     */
    protected postValues: PostTransactionValueArray<Values>;
    /**
     * @hidden
     *
     * internal event emitter to handle status changes
     */
    protected emitter: EventEmitter;
    /**
     * @hidden
     *
     * Account that will sign the transaction
     */
    protected signingAddress: string;
    /**
     * @hidden
     *
     * object that performs the payload signing logic
     */
    protected signer: PolkadotSigner;
    /**
     * @hidden
     *
     * used by procedures to set the fee manually in case the protocol op can't be
     *   dynamically generated from the transaction name, or a specific procedure has
     *   special rules for calculating them
     */
    protected protocolFee?: BigNumber;
    protected context: Context;
    /**
     * @hidden
     */
    constructor(transactionSpec: BaseTransactionSpec<Values>, context: Context);
    /**
     * Run the transaction and update its status
     */
    run(): Promise<void>;
    /**
     * @hidden
     *
     * Execute the underlying transaction, updating the status where applicable and
     *   throwing any pertinent errors
     */
    private internalRun;
    /**
     * Subscribe to status changes
     *
     * @param listener - callback function that will be called whenever the status changes
     *
     * @returns unsubscribe function
     */
    onStatusChange(listener: (transaction: this) => void): () => void;
    /**
     * Retrieve the Account that would pay fees for the transaction if it was run at this moment, as well as the total amount that can be
     *   charged to it (allowance). A null allowance means that there is no limit to that amount
     *
     * A null return value signifies that the caller Account would pay the fees
     *
     * @note this value might change if, before running the transaction, the caller Account enters (or leaves)
     *   a subsidizer relationship
     */
    getPayingAccount(): Promise<PayingAccount | null>;
    /**
     * Get all (protocol and gas) fees associated with this transaction. Returns null
     * if the transaction is not ready yet (this can happen if it depends on the execution of a
     * previous transaction in the queue)
     *
     * @note this value might change if the transaction is run at a later time. This can be due to a governance vote
     */
    getFees(): Promise<Fees | null>;
    /**
     * @hidden
     */
    protected updateStatus(status: TransactionStatus): void;
    /**
     * Return whether the transaction can be subsidized. If the result is false
     *   AND the caller is being subsidized by a third party, the transaction can't be executed and trying
     *   to do so will result in an error
     *
     * @note this depends on the type of transaction itself (i.e. `staking.bond` can't be subsidized, but `asset.createAsset` can)
     */
    abstract supportsSubsidy(): boolean;
    /**
     * @hidden
     *
     * Compose a Transaction Object with arguments that can be signed
     */
    protected abstract composeTx(): SubmittableExtrinsic<'promise', ISubmittableResult>;
    /**
     * @hidden
     *
     * Return whether the transaction ignores any existing subsidizer relationships
     *   and is always paid by the caller
     */
    protected ignoresSubsidy(): boolean;
    /**
     * @hidden
     *
     * Fetch and calculate this transaction's protocol fees
     */
    protected abstract getProtocolFees(): Promise<BigNumber>;
    /**
     * @hidden
     */
    protected handleExtrinsicFailure(_resolve: (value: ISubmittableResult | PromiseLike<ISubmittableResult>) => void, reject: (reason?: unknown) => void, error: DispatchError, data?: Record<string, unknown>): void;
    /**
     * @hidden
     */
    protected handleExtrinsicSuccess(resolve: (value: ISubmittableResult | PromiseLike<ISubmittableResult>) => void, _reject: (reason?: unknown) => void, receipt: ISubmittableResult): void;
}
//# sourceMappingURL=PolymeshTransactionBase.d.ts.map