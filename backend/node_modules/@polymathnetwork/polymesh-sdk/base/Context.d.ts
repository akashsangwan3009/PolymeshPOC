import { ApiPromise } from '@polkadot/api';
import { InterfaceTypes, Signer as PolkadotSigner } from '@polkadot/types/types';
import { SigningManager } from '@polymathnetwork/signing-manager-types';
import { NormalizedCacheObject } from 'apollo-cache-inmemory';
import ApolloClient, { ApolloQueryResult } from 'apollo-client';
import BigNumber from 'bignumber.js';
import { TxTag } from "../polkadot/types";
import { Account, Asset, Identity } from "../internal";
import { Query } from "../middleware/types";
import { AccountBalance, ClaimData, ClaimType, DistributionWithDetails, ResultSet, SubCallback, SubsidyWithAllowance, TransactionArgument, UnsubCallback } from "../types";
import { GraphqlQuery } from "../types/internal";
/**
 * @hidden
 *
 * Context in which the SDK is being used
 *
 * - Holds the polkadot API instance
 * - Holds the middleware API instance (if any)
 * - Holds the Signing Manager (if any)
 */
export declare class Context {
    private isDisconnected;
    polymeshApi: ApiPromise;
    /**
     * Whether the current node is an archive node (contains a full history from genesis onward) or not
     */
    isArchiveNode: boolean;
    ss58Format: BigNumber;
    private _middlewareApi;
    private _polymeshApi;
    private _signingManager?;
    private signingAddress?;
    /**
     * @hidden
     */
    private constructor();
    /**
     * @hidden
     */
    static createPolymeshApiProxy(ctx: Context): ApiPromise;
    /**
     * @hidden
     *
     * Create the Context instance
     */
    static create(params: {
        polymeshApi: ApiPromise;
        middlewareApi: ApolloClient<NormalizedCacheObject> | null;
        signingManager?: SigningManager;
    }): Promise<Context>;
    /**
     * @hidden
     */
    private isCurrentNodeArchive;
    /**
     * @hidden
     *
     * @note the signing Account will be set to the Signing Manager's first Account. If the Signing Manager has
     *   no Accounts yet, the signing Account will be left empty
     */
    setSigningManager(signingManager: SigningManager): Promise<void>;
    /**
     * @hidden
     */
    private get signingManager();
    /**
     * @hidden
     *
     * Retrieve a list of Accounts that can sign transactions
     */
    getSigningAccounts(): Promise<Account[]>;
    /**
     * @hidden
     *
     * Set the signing Account from among the existing ones in the Signing Manager
     *
     * @throws if the passed address isn't valid, or isn't present in the Signing Manager
     */
    setSigningAddress(signingAddress: string): Promise<void>;
    /**
     * @hidden
     *
     * Retrieve the Account POLYX balance
     *
     * @note can be subscribed to
     */
    accountBalance(account?: string | Account): Promise<AccountBalance>;
    accountBalance(account: string | Account | undefined, callback: SubCallback<AccountBalance>): Promise<UnsubCallback>;
    /**
     * @hidden
     *
     * Retrieve the Account subsidizer relationship. If there is no such relationship, return null
     *
     * @note can be subscribed to
     */
    accountSubsidy(account?: string | Account): Promise<SubsidyWithAllowance | null>;
    accountSubsidy(account: string | Account | undefined, callback: SubCallback<SubsidyWithAllowance | null>): Promise<UnsubCallback>;
    /**
     * @hidden
     *
     * Retrieve the signing Account
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAccount(): Account;
    /**
     * @hidden
     *
     * Retrieve the signing Identity
     *
     * @throws if there is no Identity associated to the signing Account (or there is no signing Account associated to the SDK instance)
     */
    getSigningIdentity(): Promise<Identity>;
    /**
     * @hidden
     *
     * Retrieve the polkadot.js promise client
     */
    getPolymeshApi(): ApiPromise;
    /**
     * @hidden
     *
     * Retrieve the signing address
     *
     * @throws if there is no signing Account associated to the SDK instance
     */
    getSigningAddress(): string;
    /**
     * @hidden
     *
     * Retrieve the external signer from the Signing Manager
     */
    getExternalSigner(): PolkadotSigner;
    /**
     * @hidden
     *
     * Check whether a set of Identities exist
     */
    getInvalidDids(identities: (string | Identity)[]): Promise<string[]>;
    /**
     * @hidden
     *
     * Returns an Identity when given a DID string
     *
     * @throws if the Identity does not exist
     */
    getIdentity(identity: Identity | string): Promise<Identity>;
    /**
     * @hidden
     *
     * Retrieve the protocol fees associated with running a specific transaction
     *
     * @param tag - transaction tag (i.e. TxTags.asset.CreateAsset or "asset.createAsset")
     */
    getProtocolFees({ tag }: {
        tag: TxTag;
    }): Promise<BigNumber>;
    /**
     * @hidden
     *
     * Return whether the passed transaction can be subsidized
     */
    supportsSubsidy({ tag }: {
        tag: TxTag;
    }): boolean;
    /**
     * Retrieve the types of arguments that a certain transaction requires to be run
     *
     * @param args.tag - tag associated with the transaction that will be executed if the proposal passes
     */
    getTransactionArguments({ tag }: {
        tag: TxTag;
    }): TransactionArgument[];
    /**
     * @hidden
     */
    getDividendDistributionsForAssets(args: {
        assets: Asset[];
    }): Promise<DistributionWithDetails[]>;
    /**
     * @hidden
     *
     * @note no claimTypes value means ALL claim types
     */
    getIdentityClaimsFromChain(args: {
        targets: (string | Identity)[];
        claimTypes?: ClaimType[];
        trustedClaimIssuers?: (string | Identity)[];
        includeExpired: boolean;
    }): Promise<ClaimData[]>;
    /**
     * @hidden
     */
    getIdentityClaimsFromMiddleware(args: {
        targets?: (string | Identity)[];
        trustedClaimIssuers?: (string | Identity)[];
        claimTypes?: Exclude<ClaimType, ClaimType.InvestorUniquenessV2>[];
        includeExpired?: boolean;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<ClaimData>>;
    /**
     * @hidden
     *
     * Retrieve a list of claims. Can be filtered using parameters
     *
     * @param opts.targets - Identities (or Identity IDs) for which to fetch claims (targets). Defaults to all targets
     * @param opts.trustedClaimIssuers - Identity IDs of claim issuers. Defaults to all claim issuers
     * @param opts.claimTypes - types of the claims to fetch. Defaults to any type
     * @param opts.includeExpired - whether to include expired claims. Defaults to true
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middleware (optional)
     */
    issuedClaims(opts?: {
        targets?: (string | Identity)[];
        trustedClaimIssuers?: (string | Identity)[];
        claimTypes?: Exclude<ClaimType, ClaimType.InvestorUniquenessV2>[];
        includeExpired?: boolean;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<ClaimData>>;
    /**
     * @hidden
     *
     * Retrieve the middleware client
     *
     * @throws if the middleware is not enabled
     */
    get middlewareApi(): ApolloClient<NormalizedCacheObject>;
    /**
     * @hidden
     *
     * Make a query to the middleware server using the apollo client
     */
    queryMiddleware<Result extends Partial<Query>>(query: GraphqlQuery<unknown>): Promise<ApolloQueryResult<Result>>;
    /**
     * @hidden
     *
     * Return whether the middleware was enabled at startup
     */
    isMiddlewareEnabled(): boolean;
    /**
     * @hidden
     *
     * Return whether the middleware is enabled and online
     */
    isMiddlewareAvailable(): Promise<boolean>;
    /**
     * @hidden
     *
     * Retrieve the latest block number
     */
    getLatestBlock(): Promise<BigNumber>;
    /**
     * @hidden
     *
     * Retrieve the network version
     */
    getNetworkVersion(): Promise<string>;
    /**
     * @hidden
     *
     * Disconnect the Polkadot API, middleware, and render this instance unusable
     *
     * @note after disconnecting, trying to access any property in this object will result
     *   in an error
     */
    disconnect(): Promise<void>;
    /**
     * @hidden
     *
     * Returns a (shallow) clone of this instance. Useful for providing a separate
     *   Context to Procedures with different signing Accounts
     */
    clone(): Context;
    /**
     *  @hidden
     *
     * Creates an instance of a type as registered in the polymeshApi instance
     */
    createType<K extends keyof InterfaceTypes>(type: K, params: unknown): InterfaceTypes[K];
}
//# sourceMappingURL=Context.d.ts.map