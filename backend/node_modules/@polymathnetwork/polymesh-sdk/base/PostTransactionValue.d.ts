import { ISubmittableResult } from '@polkadot/types/types';
import { MaybePostTransactionValue } from "../types/internal";
/**
 * @hidden
 *
 * Represents a value or method that doesn't exist at the moment, but will exist once a certain transaction
 *   has been run
 */
export declare class PostTransactionValue<Value> {
    private _value?;
    private resolved;
    private resolver;
    private runCondition;
    /**
     * Array of PostTransactionValues spawned by this one via `transform` or `merge`. We use this to keep track
     */
    private children;
    constructor(resolver: (receipt: ISubmittableResult) => Promise<Value> | Value, runCondition?: () => boolean);
    /**
     * Run the resolver function and assign its result to this object
     */
    run(receipt: ISubmittableResult): Promise<void>;
    /**
     * Retrieve the resolved value
     *
     * @throws if the value is being accessed before the resolver function has run
     */
    get value(): Value;
    /**
     * Add a new PostTransactionValue to the children array to be run when this one runs
     */
    private addChild;
    /**
     * Return a new PostTransactionValue that resolves to the value of this one processed by
     *   the passed callback. The new PostTransactionValue is resolved when this one is resolved
     */
    transform<NewValue>(callback: (val: Value) => NewValue): PostTransactionValue<NewValue>;
    /**
     * Merge this PostTransactionValue with another PostTransactionValue (or plain value), resulting in a new
     *   PostTransactionValue that resolves once these two are resolved. The resolved value is the result of passing the
     *   resolved values of both PostTransactionValues to the callback
     */
    merge<PostValue, NewValue>(postValue: MaybePostTransactionValue<PostValue>, callback: (val: Value, pval: PostValue) => NewValue): PostTransactionValue<NewValue>;
}
//# sourceMappingURL=PostTransactionValue.d.ts.map