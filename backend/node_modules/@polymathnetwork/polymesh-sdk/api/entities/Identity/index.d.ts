import BigNumber from 'bignumber.js';
import { Asset, Context, Entity, Instruction, Venue } from "../../../internal";
import { CheckRolesResult, DistributionWithDetails, GroupedInstructions, Order, PermissionedAccount, ResultSet, Role, SubCallback, UnsubCallback } from "../../../types";
import { AssetPermissions } from './AssetPermissions';
import { IdentityAuthorizations } from './IdentityAuthorizations';
import { Portfolios } from './Portfolios';
/**
 * Properties that uniquely identify an Identity
 */
export interface UniqueIdentifiers {
    did: string;
}
/**
 * Represents an Identity in the Polymesh blockchain
 */
export declare class Identity extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Checks if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Identity ID as stored in the blockchain
     */
    did: string;
    authorizations: IdentityAuthorizations;
    portfolios: Portfolios;
    assetPermissions: AssetPermissions;
    /**
     * Create an Identity entity
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Check whether this Identity possesses the specified Role
     */
    hasRole(role: Role): Promise<boolean>;
    /**
     * Retrieve the balance of a particular Asset
     *
     * @note can be subscribed to
     */
    getAssetBalance(args: {
        ticker: string;
    }): Promise<BigNumber>;
    getAssetBalance(args: {
        ticker: string;
    }, callback: SubCallback<BigNumber>): Promise<UnsubCallback>;
    /**
     * Check whether this Identity has a valid CDD claim
     */
    hasValidCdd(): Promise<boolean>;
    /**
     * Check whether this Identity is Governance Committee member
     */
    isGcMember(): Promise<boolean>;
    /**
     * Check whether this Identity is a CDD provider
     */
    isCddProvider(): Promise<boolean>;
    /**
     * Retrieve the primary Account associated with the Identity
     *
     * @note can be subscribed to
     */
    getPrimaryAccount(): Promise<PermissionedAccount>;
    getPrimaryAccount(callback: SubCallback<PermissionedAccount>): Promise<UnsubCallback>;
    /**
     * Retrieve a list of all Assets which were held at one point by this Identity
     *
     * @note uses the middleware
     * @note supports pagination
     */
    getHeldAssets(opts?: {
        order?: Order;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<Asset>>;
    /**
     * Check whether this Identity possesses all specified roles
     */
    checkRoles(roles: Role[]): Promise<CheckRolesResult>;
    /**
     * Check whether this Identity possesses all specified roles
     *
     * @deprecated in favor of `checkRoles`
     */
    hasRoles(roles: Role[]): Promise<boolean>;
    /**
     * Get the list of Assets for which this Identity is a trusted claim issuer
     *
     * @note uses the middleware
     */
    getTrustingAssets(): Promise<Asset[]>;
    /**
     * Retrieve all Venues created by this Identity
     *
     * @note can be subscribed to
     */
    getVenues(): Promise<Venue[]>;
    getVenues(callback: SubCallback<Venue[]>): Promise<UnsubCallback>;
    /**
     * Retrieve the Scope ID associated to this Identity's Investor Uniqueness Claim for a specific Asset, or null
     *   if there is none
     *
     * @note more on Investor Uniqueness {@link https://developers.polymesh.network/introduction/identity#polymesh-unique-identity-system-puis | here} and
     *   {@link https://developers.polymesh.network/polymesh-docs/primitives/confidential-identity | here}
     */
    getScopeId(args: {
        asset: Asset | string;
    }): Promise<string | null>;
    /**
     * Retrieve all Instructions where this Identity is a participant,
     *   grouped by status
     */
    getInstructions(): Promise<GroupedInstructions>;
    /**
     * Retrieve all pending Instructions involving this Identity
     *
     * @deprecated in favor of `getInstructions`
     */
    getPendingInstructions(): Promise<Instruction[]>;
    /**
     * Check whether secondary Accounts are frozen
     *
     * @note can be subscribed to
     */
    areSecondaryAccountsFrozen(): Promise<boolean>;
    areSecondaryAccountsFrozen(callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Retrieve every Dividend Distribution for which this Identity is eligible and hasn't been paid
     *
     * @note uses the middleware
     * @note this query can be potentially **SLOW** depending on which Assets this Identity has held
     */
    getPendingDistributions(): Promise<DistributionWithDetails[]>;
    /**
     * Get the list of secondary Accounts related to the Identity
     *
     * @note can be subscribed to
     */
    getSecondaryAccounts(): Promise<PermissionedAccount[]>;
    getSecondaryAccounts(callback: SubCallback<PermissionedAccount[]>): Promise<UnsubCallback>;
    /**
     * Determine whether this Identity exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Return the Identity's DID
     */
    toJson(): string;
}
//# sourceMappingURL=index.d.ts.map