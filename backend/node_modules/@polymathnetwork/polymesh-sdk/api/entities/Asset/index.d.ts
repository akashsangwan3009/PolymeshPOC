import BigNumber from 'bignumber.js';
import { AuthorizationRequest, Context, ControllerTransferParams, Entity, ModifyAssetParams, ModifyPrimaryIssuanceAgentParams, RedeemTokensParams, TransferAssetOwnershipParams } from "../../../internal";
import { EventIdentifier, HistoricAgentOperation, NoArgsProcedureMethod, ProcedureMethod, SecurityIdentifier, SubCallback, UnsubCallback } from "../../../types";
import { AssetHolders } from './AssetHolders';
import { Checkpoints } from './Checkpoints';
import { Compliance } from './Compliance';
import { CorporateActions } from './CorporateActions';
import { Documents } from './Documents';
import { Issuance } from './Issuance';
import { Offerings } from './Offerings';
import { Permissions } from './Permissions';
import { Settlements } from './Settlements';
import { TransferRestrictions } from './TransferRestrictions';
import { AssetDetails } from './types';
/**
 * Properties that uniquely identify an Asset
 */
export interface UniqueIdentifiers {
    /**
     * ticker of the Asset
     */
    ticker: string;
}
/**
 * Class used to manage all Asset functionality
 */
export declare class Asset extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Identity ID of the Asset (used for Claims)
     */
    did: string;
    /**
     * ticker of the Asset
     */
    ticker: string;
    documents: Documents;
    settlements: Settlements;
    assetHolders: AssetHolders;
    issuance: Issuance;
    compliance: Compliance;
    transferRestrictions: TransferRestrictions;
    offerings: Offerings;
    checkpoints: Checkpoints;
    corporateActions: CorporateActions;
    permissions: Permissions;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Transfer ownership of the Asset to another Identity. This generates an authorization request that must be accepted
     *   by the recipient
     *
     * @note this will create {@link AuthorizationRequest | Authorization Request} which has to be accepted by the `target` Identity.
     *   An {@link Account} or {@link Identity} can fetch its pending Authorization Requests by calling {@link Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link Authorizations.getOne | authorizations.getOne}
     */
    transferOwnership: ProcedureMethod<TransferAssetOwnershipParams, AuthorizationRequest>;
    /**
     * Modify some properties of the Asset
     *
     * @throws if the passed values result in no changes being made to the Asset
     */
    modify: ProcedureMethod<ModifyAssetParams, Asset>;
    /**
     * Retrieve the Asset's data
     *
     * @note can be subscribed to
     */
    details(): Promise<AssetDetails>;
    details(callback: SubCallback<AssetDetails>): Promise<UnsubCallback>;
    /**
     * Retrieve the Asset's funding round
     *
     * @note can be subscribed to
     */
    currentFundingRound(): Promise<string | null>;
    currentFundingRound(callback: SubCallback<string | null>): Promise<UnsubCallback>;
    /**
     * Retrieve the Asset's identifiers list
     *
     * @note can be subscribed to
     */
    getIdentifiers(): Promise<SecurityIdentifier[]>;
    getIdentifiers(callback?: SubCallback<SecurityIdentifier[]>): Promise<UnsubCallback>;
    /**
     * Retrieve the identifier data (block number, date and event index) of the event that was emitted when the token was created
     *
     * @note uses the middleware
     * @note there is a possibility that the data is not ready by the time it is requested. In that case, `null` is returned
     */
    createdAt(): Promise<EventIdentifier | null>;
    /**
     * Freeze transfers and minting of the Asset
     */
    freeze: NoArgsProcedureMethod<Asset>;
    /**
     * Unfreeze transfers and minting of the Asset
     */
    unfreeze: NoArgsProcedureMethod<Asset>;
    /**
     * Check whether transfers are frozen for the Asset
     *
     * @note can be subscribed to
     */
    isFrozen(): Promise<boolean>;
    isFrozen(callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Assign a new primary issuance agent for the Asset
     *
     * @note this will create an {@link AuthorizationRequest | Authorization Request} which has to be accepted by the `target` Identity.
     *   An {@link Account} or {@link Identity} can fetch its pending Authorization Requests by calling {@link Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link Authorizations.getOne | authorizations.getOne}
     *
     * @deprecated in favor of `inviteAgent`
     */
    modifyPrimaryIssuanceAgent: ProcedureMethod<ModifyPrimaryIssuanceAgentParams, void>;
    /**
     * Remove the primary issuance agent of the Asset
     *
     * @note if primary issuance agent is not set, Asset owner would be used by default
     *
     * @deprecated
     */
    removePrimaryIssuanceAgent: NoArgsProcedureMethod<void>;
    /**
     * Redeem (burn) an amount of this Asset's tokens
     *
     * @note tokens are removed from the caller's Default Portfolio
     */
    redeem: ProcedureMethod<RedeemTokensParams, void>;
    /**
     * Retrieve the amount of unique investors that hold this Asset
     *
     * @note this takes into account the Scope ID of Investor Uniqueness Claims. If an investor holds balances
     *   of this Asset in two or more different Identities, but they all have Investor Uniqueness Claims with the same
     *   Scope ID, then they will only be counted once for the purposes of this result
     *
     * @note can be subscribed to
     */
    investorCount(): Promise<BigNumber>;
    investorCount(callback: SubCallback<BigNumber>): Promise<UnsubCallback>;
    /**
     * Force a transfer from a given Portfolio to the callerâ€™s default Portfolio
     */
    controllerTransfer: ProcedureMethod<ControllerTransferParams, void>;
    /**
     * Retrieve this Asset's Operation History
     *
     * @note Operations are grouped by the agent Identity who performed them
     *
     * @note uses the middleware
     */
    getOperationHistory(): Promise<HistoricAgentOperation[]>;
    /**
     * Determine whether this Asset exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Return the Asset's ticker
     */
    toJson(): string;
}
//# sourceMappingURL=index.d.ts.map