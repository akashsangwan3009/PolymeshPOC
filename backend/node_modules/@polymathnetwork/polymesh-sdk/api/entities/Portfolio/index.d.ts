import BigNumber from 'bignumber.js';
import { Asset, AuthorizationRequest, Context, Entity, Identity, MoveFundsParams, SetCustodianParams } from "../../../internal";
import { NoArgsProcedureMethod, ProcedureMethod, ResultSet } from "../../../types";
import { HistoricSettlement, PortfolioBalance } from './types';
export interface UniqueIdentifiers {
    did: string;
    id?: BigNumber;
}
interface HumanReadable {
    did: string;
    id?: string;
}
/**
 * Represents a base Portfolio for a specific Identity in the Polymesh blockchain
 */
export declare abstract class Portfolio extends Entity<UniqueIdentifiers, HumanReadable> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Identity of the Portfolio's owner
     */
    owner: Identity;
    /**
     * internal Portfolio identifier (unused for default Portfolio)
     */
    protected _id?: BigNumber;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Return whether an Identity is the Portfolio owner
     *
     * @param args.identity - defaults to the signing Identity
     */
    isOwnedBy(args?: {
        identity: string | Identity;
    }): Promise<boolean>;
    /**
     * Return whether an Identity is the Portfolio custodian
     *
     * @param args.identity - optional, defaults to the signing Identity
     */
    isCustodiedBy(args?: {
        identity: string | Identity;
    }): Promise<boolean>;
    /**
     * Retrieve the balances of all Assets in this Portfolio
     *
     * @param args.assets - array of Assets (or tickers) for which to fetch balances (optional, all balances are retrieved if not passed)
     */
    getAssetBalances(args?: {
        assets: (string | Asset)[];
    }): Promise<PortfolioBalance[]>;
    /**
     * Send an invitation to an Identity to assign it as custodian for this Portfolio
     *
     * @note this will create an {@link AuthorizationRequest | Authorization Request} which has to be accepted by the `targetIdentity`.
     *   An {@link Account} or {@link Identity} can fetch its pending Authorization Requests by calling {@link Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link Authorizations.getOne | authorizations.getOne}
     *
     * @note required role:
     *   - Portfolio Custodian
     */
    setCustodian: ProcedureMethod<SetCustodianParams, AuthorizationRequest>;
    /**
     * Moves funds from this Portfolio to another one owned by the same Identity
     *
     * @note required role:
     *   - Portfolio Custodian
     */
    moveFunds: ProcedureMethod<MoveFundsParams, void>;
    /**
     * Returns the custody of the portfolio to the portfolio owner unilaterally
     *
     * @note required role:
     *   - Portfolio Custodian
     */
    quitCustody: NoArgsProcedureMethod<void>;
    /**
     * Retrieve the custodian Identity of this Portfolio
     *
     * @note if no custodian is set, the owner Identity is returned
     */
    getCustodian(): Promise<Identity>;
    /**
     * Retrieve a list of transactions where this portfolio was involved. Can be filtered using parameters
     *
     * @param filters.account - Account involved in the settlement
     * @param filters.ticker - ticker involved in the transaction
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note supports pagination
     * @note uses the middleware
     */
    getTransactionHistory(filters?: {
        account?: string;
        ticker?: string;
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<HistoricSettlement>>;
    /**
     * Return the Portfolio ID and owner DID
     */
    toJson(): HumanReadable;
}
export {};
//# sourceMappingURL=index.d.ts.map