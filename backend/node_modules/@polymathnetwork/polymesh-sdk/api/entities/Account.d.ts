import BigNumber from 'bignumber.js';
import { Authorizations, Context, Entity, Identity } from "../../internal";
import { TransactionOrderByInput } from "../../middleware/types";
import { AccountBalance, CheckPermissionsResult, ExtrinsicData, Permissions, ResultSet, SignerType, SimplePermissions, SubCallback, SubsidyWithAllowance, TxTag, UnsubCallback } from "../../types";
export interface UniqueIdentifiers {
    address: string;
}
/**
 * Represents an Account in the Polymesh blockchain. Accounts can hold POLYX, control Identities and vote on proposals (among other things)
 */
export declare class Account extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Polymesh-specific address of the Account. Serves as an identifier
     */
    address: string;
    /**
     * A hex representation of the cryptographic public key of the Account. This is consistent across
     * Substrate chains, while the address depends on the chain as well.
     */
    key: string;
    authorizations: Authorizations<Account>;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Get the free/locked POLYX balance of the Account
     *
     * @note can be subscribed to
     */
    getBalance(): Promise<AccountBalance>;
    getBalance(callback: SubCallback<AccountBalance>): Promise<UnsubCallback>;
    /**
     * Get the subsidized balance of this Account and the subsidizer Account. If
     *   this Account isn't being subsidized, return null
     *
     * @note can be subscribed to
     */
    getSubsidy(): Promise<SubsidyWithAllowance | null>;
    getSubsidy(callback: SubCallback<SubsidyWithAllowance | null>): Promise<UnsubCallback>;
    /**
     * Retrieve the Identity associated to this Account (null if there is none)
     */
    getIdentity(): Promise<Identity | null>;
    /**
     * Retrieve a list of transactions signed by this Account. Can be filtered using parameters
     *
     * @note if both `blockNumber` and `blockHash` are passed, only `blockNumber` is taken into account
     *
     * @param filters.tag - tag associated with the transaction
     * @param filters.success - whether the transaction was successful or not
     * @param filters.size - page size
     * @param filters.start - page offset
     *
     * @note uses the middleware
     */
    getTransactionHistory(filters?: {
        blockNumber?: BigNumber;
        blockHash?: string;
        tag?: TxTag;
        success?: boolean;
        size?: BigNumber;
        start?: BigNumber;
        orderBy?: TransactionOrderByInput;
    }): Promise<ResultSet<ExtrinsicData>>;
    /**
     * Check whether this Account is frozen. If frozen, it cannot perform any action until the primary Account of the Identity unfreezes all secondary Accounts
     */
    isFrozen(): Promise<boolean>;
    /**
     * Retrieve the Permissions this Account has as a Permissioned Account for its corresponding Identity
     *
     * @throws if there is no Identity associated with the Account
     */
    getPermissions(): Promise<Permissions>;
    /**
     * Check if this Account possesses certain Permissions to act on behalf of its corresponding Identity
     *
     * @return which permissions the Account is missing (if any) and the final result
     */
    checkPermissions(permissions: SimplePermissions): Promise<CheckPermissionsResult<SignerType.Account>>;
    /**
     * Check if this Account possesses certain Permissions to act on behalf of its corresponding Identity
     *
     * @deprecated in favor of `checkPermissions`
     */
    hasPermissions(permissions: SimplePermissions): Promise<boolean>;
    /**
     * Determine whether this Account exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Return the Account's address
     */
    toJson(): string;
}
//# sourceMappingURL=Account.d.ts.map