import BigNumber from 'bignumber.js';
import { Context, Entity } from "../../../internal";
import { NoArgsProcedureMethod, PaginationOptions, ResultSet } from "../../../types";
import { InstructionAffirmation, InstructionDetails, InstructionStatusResult, Leg } from './types';
export interface UniqueIdentifiers {
    id: BigNumber;
}
/**
 * Represents a settlement Instruction to be executed on a certain Venue
 */
export declare class Instruction extends Entity<UniqueIdentifiers, string> {
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Identifier number of the venue
     */
    id: BigNumber;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Retrieve whether the Instruction has already been executed and pruned from
     *   the chain.
     */
    isExecuted(): Promise<boolean>;
    /**
     * Retrieve whether the Instruction is still pending on chain
     */
    isPending(): Promise<boolean>;
    /**
     * Determine whether this Instruction exists on chain (or existed and was pruned)
     */
    exists(): Promise<boolean>;
    /**
     * Retrieve information specific to this Instruction
     */
    details(): Promise<InstructionDetails>;
    /**
     * Retrieve every authorization generated by this Instruction (status and authorizing Identity)
     *
     * @note supports pagination
     */
    getAffirmations(paginationOpts?: PaginationOptions): Promise<ResultSet<InstructionAffirmation>>;
    /**
     * Retrieve all legs of this Instruction
     *
     * @note supports pagination
     */
    getLegs(paginationOpts?: PaginationOptions): Promise<ResultSet<Leg>>;
    /**
     * Retrieve current status of this Instruction
     *
     * @note uses the middleware
     */
    getStatus(): Promise<InstructionStatusResult>;
    /**
     * Reject this instruction
     *
     * @note reject on `SettleOnAffirmation` will execute the settlement and it will fail immediately.
     * @note reject on `SettleOnBlock` behaves just like unauthorize
     */
    reject: NoArgsProcedureMethod<Instruction>;
    /**
     * Affirm this instruction (authorize)
     */
    affirm: NoArgsProcedureMethod<Instruction>;
    /**
     * Withdraw affirmation from this instruction (unauthorize)
     */
    withdraw: NoArgsProcedureMethod<Instruction>;
    /**
     * Reschedules a failed Instruction to be tried again
     *
     * @throws if the Instruction status is not `InstructionStatus.Failed`
     */
    reschedule: NoArgsProcedureMethod<Instruction>;
    /**
     * @hidden
     * Retrieve Instruction status event from middleware
     */
    private getInstructionEventFromMiddleware;
    /**
     * Return the Instruction's ID
     */
    toJson(): string;
}
//# sourceMappingURL=index.d.ts.map