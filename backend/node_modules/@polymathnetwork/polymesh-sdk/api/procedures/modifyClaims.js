"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyClaims = exports.getAuthorization = exports.prepareModifyClaims = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const queries_1 = require("../../middleware/queries");
const types_1 = require("../../types");
const internal_2 = require("../../types/internal");
const utils_1 = require("../../types/utils");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_3 = require("../../utils/internal");
const typeguards_1 = require("../../utils/typeguards");
const areSameClaims = (claim, { scope, type }) => {
    let isSameScope = true;
    if ((0, typeguards_1.isScopedClaim)(claim)) {
        isSameScope = scope ? (0, lodash_1.isEqual)((0, conversion_1.middlewareScopeToScope)(scope), claim.scope) : false;
    }
    return isSameScope && types_1.ClaimType[type] === claim.type;
};
const findClaimsByOtherIssuers = (claims, claimsByDid) => claims.reduce((prev, { target, claim }) => {
    var _a;
    const targetClaims = (_a = claimsByDid[(0, conversion_1.signerToString)(target)]) !== null && _a !== void 0 ? _a : [];
    const claimExists = !!targetClaims.find(targetClaim => areSameClaims(claim, targetClaim));
    if (!claimExists) {
        return [...prev, claim];
    }
    return [...prev];
}, []);
const findPositiveBalanceIuClaims = (claims, context) => bluebird_1.default.reduce(claims, (prev, { claim }) => __awaiter(void 0, void 0, void 0, function* () {
    if ((0, typeguards_1.isInvestorUniquenessClaim)(claim)) {
        const { scope: { value }, scopeId, } = claim;
        const balance = yield context.polymeshApi.query.asset.aggregateBalance((0, conversion_1.stringToTicker)(value, context), (0, conversion_1.stringToScopeId)(scopeId, context));
        if (!(0, conversion_1.balanceToBigNumber)(balance).isZero()) {
            return [...prev, claim];
        }
    }
    return [...prev];
}), []);
/**
 * @hidden
 *
 * Return all new CDD claims for Identities that have an existing CDD claim with a different ID
 */
const findInvalidCddClaims = (claims, context) => __awaiter(void 0, void 0, void 0, function* () {
    const invalidCddClaims = [];
    const newCddClaims = claims.filter(({ claim: { type } }) => type === types_1.ClaimType.CustomerDueDiligence);
    if (newCddClaims.length) {
        const issuedCddClaims = yield context.issuedClaims({
            targets: newCddClaims.map(({ target }) => target),
            claimTypes: [types_1.ClaimType.CustomerDueDiligence],
            includeExpired: false,
        });
        newCddClaims.forEach(({ target, claim }) => {
            const targetIdentity = (0, internal_3.asIdentity)(target, context);
            const issuedClaimsForTarget = issuedCddClaims.data.filter(({ target: issuedTarget }) => targetIdentity.isEqual(issuedTarget));
            if (issuedClaimsForTarget.length) {
                // we know both claims are CDD claims
                const { id: currentCddId } = issuedClaimsForTarget[0].claim;
                const { id: newCddId } = claim;
                if (newCddId !== currentCddId && ![currentCddId, newCddId].includes(constants_1.DEFAULT_CDD_ID)) {
                    invalidCddClaims.push({
                        target: targetIdentity,
                        currentCddId,
                        newCddId,
                    });
                }
            }
        });
    }
    return invalidCddClaims;
});
/**
 * @hidden
 */
function prepareModifyClaims(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { claims, operation } = args;
        const { context: { polymeshApi: { tx: { identity }, }, }, context, } = this;
        const modifyClaimArgs = [];
        let allTargets = [];
        claims.forEach(({ target, expiry, claim }) => {
            const rawExpiry = expiry ? (0, conversion_1.dateToMoment)(expiry, context) : null;
            allTargets.push((0, conversion_1.signerToString)(target));
            modifyClaimArgs.push((0, utils_1.tuple)((0, conversion_1.stringToIdentityId)((0, conversion_1.signerToString)(target), context), (0, conversion_1.claimToMeshClaim)(claim, context), rawExpiry));
        });
        allTargets = (0, lodash_1.uniq)(allTargets);
        const [nonExistentDids, middlewareAvailable] = yield Promise.all([
            context.getInvalidDids(allTargets),
            context.isMiddlewareAvailable(),
        ]);
        if (nonExistentDids.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.DataUnavailable,
                message: 'Some of the supplied Identity IDs do not exist',
                data: {
                    nonExistentDids,
                },
            });
        }
        const shouldValidateWithMiddleware = operation !== internal_2.ClaimOperation.Add && middlewareAvailable;
        // skip validation if the middleware is unavailable
        if (shouldValidateWithMiddleware) {
            const { did: currentDid } = yield context.getSigningIdentity();
            const { data: { didsWithClaims: { items: currentClaims }, }, } = yield context.queryMiddleware((0, queries_1.didsWithClaims)({
                dids: allTargets,
                trustedClaimIssuers: [currentDid],
                includeExpired: true,
                count: allTargets.length,
            }));
            const claimsByDid = currentClaims.reduce((prev, { did, claims: didClaims }) => {
                const copy = (0, lodash_1.cloneDeep)(prev);
                copy[did] = didClaims;
                return copy;
            }, {});
            const claimsByOtherIssuers = findClaimsByOtherIssuers(claims, claimsByDid);
            if (claimsByOtherIssuers.length) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: `Attempt to ${operation.toLowerCase()} claims that weren't issued by the signing Identity`,
                    data: {
                        claimsByOtherIssuers,
                    },
                });
            }
        }
        if (operation === internal_2.ClaimOperation.Revoke) {
            const claimsWithBalance = yield findPositiveBalanceIuClaims(claims, context);
            if (claimsWithBalance.length) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.EntityInUse,
                    message: 'Attempt to revoke Investor Uniqueness claims from investors with positive balance',
                    data: {
                        claimsWithBalance,
                    },
                });
            }
            const transactions = (0, internal_3.assembleBatchTransactions)((0, utils_1.tuple)({
                transaction: identity.revokeClaim,
                argsArray: modifyClaimArgs.map(([identityId, claim]) => (0, utils_1.tuple)(identityId, claim)),
            }));
            this.addBatchTransaction({ transactions });
            return;
        }
        if (operation === internal_2.ClaimOperation.Add) {
            const invalidCddClaims = yield findInvalidCddClaims(claims, context);
            if (invalidCddClaims.length) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.UnmetPrerequisite,
                    message: 'A target Identity cannot have CDD claims with different IDs',
                    data: {
                        invalidCddClaims,
                    },
                });
            }
        }
        const txs = (0, internal_3.assembleBatchTransactions)((0, utils_1.tuple)({
            transaction: identity.addClaim,
            argsArray: modifyClaimArgs,
        }));
        this.addBatchTransaction({ transactions: txs });
    });
}
exports.prepareModifyClaims = prepareModifyClaims;
/**
 * @hidden
 */
function getAuthorization({ claims, operation, }) {
    const permissions = {
        transactions: [
            operation === internal_2.ClaimOperation.Revoke ? types_1.TxTags.identity.RevokeClaim : types_1.TxTags.identity.AddClaim,
        ],
        assets: [],
        portfolios: [],
    };
    if (claims.some(({ claim: { type } }) => type === types_1.ClaimType.CustomerDueDiligence)) {
        return {
            roles: [{ type: types_1.RoleType.CddProvider }],
            permissions,
        };
    }
    return {
        permissions,
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
const modifyClaims = () => new internal_1.Procedure(prepareModifyClaims, getAuthorization);
exports.modifyClaims = modifyClaims;
//# sourceMappingURL=modifyClaims.js.map