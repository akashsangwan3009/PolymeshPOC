import { ISubmittableResult } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { Account, AuthorizationRequest, Checkpoint, CheckpointSchedule, Context, CustomPermissionGroup, Identity, Instruction, KnownPermissionGroup } from "../../internal";
import { AddRelayerPayingKeyAuthorizationData, Authorization, Condition, GenericAuthorizationData, InputCondition, InputTargets, InputTaxWithholding, PermissionedAccount, Signer } from "../../types";
import { MaybePostTransactionValue, PortfolioId } from "../../types/internal";
/**
 * @hidden
 */
export declare function assertInstructionValid(instruction: Instruction, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertPortfolioExists(portfolioId: PortfolioId, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertVenueExists(venueId: BigNumber, context: Context): Promise<void>;
/**
 * @hidden
 */
export declare function assertSecondaryAccounts(accounts: Account[], secondaryAccounts: PermissionedAccount[]): void;
/**
 * @hidden
 */
export declare function assertDistributionOpen(paymentDate: Date, expiryDate: Date | null): void;
/**
 * @hidden
 */
export declare function assertCaTargetsValid(targets: InputTargets, context: Context): void;
/**
 * @hidden
 */
export declare function assertCaTaxWithholdingsValid(taxWithholdings: InputTaxWithholding[], context: Context): void;
/**
 * @hidden
 */
export declare function assertCaCheckpointValid(checkpoint: Checkpoint | CheckpointSchedule | Date): Promise<void>;
/**
 * @hidden
 */
export declare function assertDistributionDatesValid(checkpoint: CheckpointSchedule | Date, paymentDate: Date, expiryDate: Date | null): Promise<void>;
/**
 * @hidden
 */
export declare function isFullGroupType(group: KnownPermissionGroup | CustomPermissionGroup): boolean;
/**
 * @hidden
 *
 * @note based on the complexity calculation done by the chain
 * @note conditions have already been "injected" with the default trusted claim issuers when they reach this point
 */
export declare function assertRequirementsNotTooComplex(conditions: (Condition | InputCondition)[], defaultClaimIssuerLength: BigNumber, context: Context): void;
/**
 * @hidden
 *
 * Asserts valid primary key rotation authorization
 */
export declare function assertPrimaryKeyRotationAuthorizationValid(authRequest: AuthorizationRequest): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid attest primary key authorization
 */
export declare function assertAttestPrimaryKeyAuthorizationValid(authRequest: AuthorizationRequest): Promise<void>;
/**
 * @hidden
 *
 * Asserts transfer ticker authorization is valid
 */
export declare function assertTransferTickerAuthorizationValid(data: GenericAuthorizationData, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid transfer asset ownership authorization
 */
export declare function assertTransferAssetOwnershipAuthorizationValid(data: GenericAuthorizationData, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid add multisig signer authorization
 */
export declare function assertMultiSigSignerAuthorizationValid(data: GenericAuthorizationData, target: Signer, context: Context): Promise<void>;
/**
 * @hidden
 *
 * Asserts valid add relayer paying key authorization
 */
export declare function assertAddRelayerPayingKeyAuthorizationValid(data: AddRelayerPayingKeyAuthorizationData): Promise<void>;
/**
 * @hidden
 *
 * Helper class to ensure a code path is unreachable. For example this can be used for ensuring switch statements are exhaustive
 */
export declare class UnreachableCaseError extends Error {
    /** This should never be called */
    constructor(val: never);
}
/**
 * @hidden
 */
export declare function assertAuthorizationRequestValid(authRequest: AuthorizationRequest, context: Context): Promise<void>;
export declare const createAuthorizationResolver: (auth: MaybePostTransactionValue<Authorization>, issuer: Identity, target: Identity | Account, expiry: Date | null, context: Context) => (receipt: ISubmittableResult) => AuthorizationRequest;
//# sourceMappingURL=utils.d.ts.map