"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTransferRestrictions = exports.prepareStorage = exports.getAuthorization = exports.prepareSetTransferRestrictions = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const utils_1 = require("../../types/utils");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
function prepareSetTransferRestrictions(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { statistics }, consts, }, }, storage: { restrictionsToAdd, restrictionsToRemove, exemptionsToAdd, exemptionsToRemove, occupiedSlots, }, } = this;
        const { restrictions: { length: newRestrictionAmount }, } = args;
        const restrictionsToAddAmount = restrictionsToAdd.length;
        const restrictionsToRemoveAmount = restrictionsToRemove.length;
        const exemptionsToAddAmount = exemptionsToAdd.length;
        const exemptionsToRemoveAmount = exemptionsToRemove.length;
        if (!restrictionsToAddAmount &&
            !restrictionsToRemoveAmount &&
            !exemptionsToAddAmount &&
            !exemptionsToRemoveAmount) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.NoDataChange,
                message: newRestrictionAmount
                    ? 'The supplied restrictions are already in place'
                    : 'There are no restrictions to remove',
            });
        }
        const maxTransferManagers = (0, conversion_1.u32ToBigNumber)(consts.statistics.maxTransferManagersPerAsset);
        const finalCount = occupiedSlots.plus(newRestrictionAmount);
        if (finalCount.gte(maxTransferManagers)) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.LimitExceeded,
                message: 'Cannot set more Transfer Restrictions than there are slots available',
                data: {
                    availableSlots: maxTransferManagers.minus(occupiedSlots),
                },
            });
        }
        const transactions = (0, internal_2.assembleBatchTransactions)((0, utils_1.tuple)({
            transaction: statistics.removeTransferManager,
            argsArray: restrictionsToRemove,
        }, {
            transaction: statistics.addTransferManager,
            argsArray: restrictionsToAdd,
        }, {
            transaction: statistics.removeExemptedEntities,
            argsArray: exemptionsToRemove,
        }, {
            transaction: statistics.addExemptedEntities,
            argsArray: exemptionsToAdd,
        }));
        this.addBatchTransaction({ transactions });
        return finalCount;
    });
}
exports.prepareSetTransferRestrictions = prepareSetTransferRestrictions;
/**
 * @hidden
 */
function getAuthorization({ ticker }) {
    const { restrictionsToRemove, restrictionsToAdd, exemptionsToAdd, exemptionsToRemove } = this.storage;
    const transactions = [];
    if (restrictionsToAdd.length) {
        transactions.push(types_1.TxTags.statistics.AddTransferManager);
    }
    if (restrictionsToRemove.length) {
        transactions.push(types_1.TxTags.statistics.RemoveTransferManager);
    }
    if (exemptionsToAdd.length) {
        transactions.push(types_1.TxTags.statistics.AddExemptedEntities);
    }
    if (exemptionsToRemove.length) {
        transactions.push(types_1.TxTags.statistics.RemoveExemptedEntities);
    }
    return {
        permissions: {
            assets: [new internal_1.Asset({ ticker }, this.context)],
            transactions,
            portfolios: [],
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const { ticker, type, restrictions } = args;
        const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
        const { transferRestrictions: { count, percentage }, } = new internal_1.Asset({ ticker }, context);
        const [{ restrictions: currentCountRestrictions }, { restrictions: currentPercentageRestrictions },] = yield Promise.all([count.get(), percentage.get()]);
        const currentRestrictions = [];
        const currentExemptions = [];
        const toAddRestrictions = [];
        const toAddExemptionPromises = [];
        let occupiedSlots = currentCountRestrictions.length + currentPercentageRestrictions.length;
        /*
         * we're using `defusePromise` here because we KNOW the exempted ID promises are being
         * awaited later and errors WILL be caught
         */
        if (type === types_1.TransferRestrictionType.Count) {
            restrictions.forEach(({ exemptedIdentities = [], count: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Count, value };
                toAddRestrictions.push(restriction);
                toAddExemptionPromises.push((0, utils_1.tuple)(restriction, (0, internal_2.defusePromise)((0, internal_2.getExemptedIds)(exemptedIdentities, context, ticker))));
            });
            currentCountRestrictions.forEach(({ exemptedIds = [], count: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Count, value };
                currentRestrictions.push(restriction);
                currentExemptions.push((0, utils_1.tuple)(restriction, exemptedIds));
            });
        }
        else {
            restrictions.forEach(({ exemptedIdentities = [], percentage: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Percentage, value };
                toAddRestrictions.push(restriction);
                toAddExemptionPromises.push((0, utils_1.tuple)(restriction, (0, internal_2.defusePromise)((0, internal_2.getExemptedIds)(exemptedIdentities, context, ticker))));
            });
            currentPercentageRestrictions.forEach(({ exemptedIds = [], percentage: value }) => {
                const restriction = { type: types_1.TransferRestrictionType.Percentage, value };
                currentRestrictions.push(restriction);
                currentExemptions.push((0, utils_1.tuple)(restriction, exemptedIds));
            });
        }
        const toAddExemptions = yield bluebird_1.default.map(toAddExemptionPromises, ([restriction, exemptedPromise]) => __awaiter(this, void 0, void 0, function* () {
            const exempted = yield exemptedPromise;
            return (0, utils_1.tuple)(restriction, exempted);
        }));
        const newRestrictions = (0, lodash_1.differenceWith)(toAddRestrictions, currentRestrictions, lodash_1.isEqual);
        const toRemoveRestrictions = (0, lodash_1.differenceWith)(currentRestrictions, toAddRestrictions, lodash_1.isEqual);
        const transformRestriction = (restriction) => (0, utils_1.tuple)(rawTicker, (0, conversion_1.transferRestrictionToTransferManager)(restriction, context));
        const restrictionsToRemove = toRemoveRestrictions.map(transformRestriction);
        const restrictionsToAdd = newRestrictions.map(transformRestriction);
        occupiedSlots -= currentRestrictions.length;
        const newExemptions = [];
        const toRemoveExemptions = [];
        toAddExemptions.forEach(exemption => {
            const [restriction, exempted] = exemption;
            if (newRestrictions.find(res => (0, lodash_1.isEqual)(restriction, res)) && exempted.length) {
                newExemptions.push(exemption);
                return;
            }
            const currentExemption = currentExemptions.find(([res]) => (0, lodash_1.isEqual)(res, restriction));
            const currentExempted = (currentExemption === null || currentExemption === void 0 ? void 0 : currentExemption[1]) || [];
            // Scope/Identity IDs that weren't exempted before for that restriction
            const newExempted = (0, lodash_1.difference)(exempted, currentExempted);
            if (newExempted.length) {
                newExemptions.push((0, utils_1.tuple)(restriction, newExempted));
            }
            // Scope/Identity IDs that will no longer be exempted for that restriction
            const toRemoveExempted = (0, lodash_1.difference)(currentExempted, exempted);
            if (toRemoveExempted.length) {
                toRemoveExemptions.push((0, utils_1.tuple)(restriction, toRemoveExempted));
            }
        });
        // also remove all exemptions of the restrictions that will be removed
        toRemoveRestrictions.forEach(restriction => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [, currentExempted] = currentExemptions.find(([res]) => (0, lodash_1.isEqual)(res, restriction));
            if (currentExempted.length) {
                toRemoveExemptions.push((0, utils_1.tuple)(restriction, currentExempted));
            }
        });
        const transformExemptions = ([restriction, entityIds]) => (0, utils_1.tuple)(rawTicker, (0, conversion_1.transferRestrictionToTransferManager)(restriction, context), 
        // we use `stringToScopeId` because both `ScopeId` and `IdentityId` are aliases for `U8aFixed`
        entityIds.map(entityId => (0, conversion_1.stringToScopeId)(entityId, context)));
        const exemptionsToAdd = newExemptions.map(transformExemptions);
        const exemptionsToRemove = toRemoveExemptions.map(transformExemptions);
        return {
            restrictionsToRemove,
            restrictionsToAdd,
            exemptionsToAdd,
            exemptionsToRemove,
            occupiedSlots: new bignumber_js_1.default(occupiedSlots),
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const setTransferRestrictions = () => new internal_1.Procedure(prepareSetTransferRestrictions, getAuthorization, prepareStorage);
exports.setTransferRestrictions = setTransferRestrictions;
//# sourceMappingURL=setTransferRestrictions.js.map