"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManagement = void 0;
const internal_1 = require("./internal");
const types_1 = require("./types");
const internal_2 = require("./utils/internal");
/**
 * Handles functionality related to Account Management
 */
class AccountManagement {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.leaveIdentity = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: () => [internal_1.leaveIdentity, undefined], voidArgs: true }, context);
        this.removeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [internal_1.removeSecondaryAccounts, Object.assign({}, args)],
        }, context);
        this.revokePermissions = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => {
                const { secondaryAccounts } = args;
                const accounts = secondaryAccounts.map(account => {
                    return {
                        account,
                        permissions: {
                            tokens: { type: types_1.PermissionType.Include, values: [] },
                            transactions: { type: types_1.PermissionType.Include, values: [] },
                            portfolios: { type: types_1.PermissionType.Include, values: [] },
                        },
                    };
                });
                return [internal_1.modifySignerPermissions, { secondaryAccounts: accounts }];
            },
        }, context);
        this.modifyPermissions = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.modifySignerPermissions, Object.assign({}, args)] }, context);
        this.inviteAccount = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.inviteAccount, Object.assign({}, args)] }, context);
        this.freezeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeSecondaryAccounts, { freeze: true }],
            voidArgs: true,
        }, context);
        this.unfreezeSecondaryAccounts = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [internal_1.toggleFreezeSecondaryAccounts, { freeze: false }],
            voidArgs: true,
        }, context);
        this.subsidizeAccount = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.subsidizeAccount, Object.assign({}, args)] }, context);
    }
    // eslint-disable-next-line require-jsdoc
    getAccountBalance(args, callback) {
        const { context } = this;
        let account;
        let cb = callback;
        switch (typeof args) {
            case 'undefined': {
                break;
            }
            case 'function': {
                cb = args;
                break;
            }
            default: {
                ({ account } = args);
                break;
            }
        }
        if (!account) {
            account = context.getSigningAccount();
        }
        else if (typeof account === 'string') {
            account = new internal_1.Account({ address: account }, context);
        }
        if (cb) {
            return account.getBalance(cb);
        }
        return account.getBalance();
    }
    /**
     * Return an Account instance from an address
     */
    getAccount(args) {
        const { context } = this;
        return new internal_1.Account(args, context);
    }
    /**
     * Return the signing Account, or null if no signing Account has been set
     */
    getSigningAccount() {
        try {
            return this.context.getSigningAccount();
        }
        catch (err) {
            return null;
        }
    }
    /**
     * Return a list that contains all the signing Accounts associated to the SDK instance's Signing Manager
     *
     * @throws â€” if there is no Signing Manager attached to the SDK
     */
    getSigningAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getSigningAccounts();
        });
    }
}
exports.AccountManagement = AccountManagement;
//# sourceMappingURL=AccountManagement.js.map