import { AugmentedEvent, AugmentedQuery, AugmentedQueryDoubleMap, ObsInnerType } from '@polkadot/api/types';
import { StorageKey } from '@polkadot/types';
import { BlockHash } from '@polkadot/types/interfaces/chain';
import { AnyFunction, AnyTuple, IEvent, ISubmittableResult } from '@polkadot/types/types';
import BigNumber from 'bignumber.js';
import { IdentityId, ModuleName, PortfolioName, TxTag } from "../polkadot/types";
import { Asset, Checkpoint, CheckpointSchedule, Context, Identity } from "../internal";
import { Scope as MiddlewareScope } from "../middleware/types";
import { CalendarPeriod, Claim, Condition, InputCaCheckpoint, InputCondition, NextKey, NoArgsProcedureMethod, PaginationOptions, ProcedureMethod } from "../types";
import { Events, Falsyable, MapMaybePostTransactionValue, MapTxWithArgs, MaybePostTransactionValue, PolymeshTx, TxWithArgs } from "../types/internal";
import { HumanReadableType, ProcedureFunc, UnionOfProcedureFuncs } from "../types/utils";
export * from "../generated/utils";
/**
 * @hidden
 * Promisified version of a timeout
 *
 * @param amount - time to wait
 */
export declare function delay(amount: number): Promise<void>;
/**
 * @hidden
 * Convert an entity type and its unique Identifiers to a base64 string
 */
export declare function serialize<UniqueIdentifiers>(entityType: string, uniqueIdentifiers: UniqueIdentifiers): string;
/**
 * @hidden
 * Convert a uuid string to an Identifier object
 */
export declare function unserialize<UniqueIdentifiers>(id: string): UniqueIdentifiers;
/**
 * @hidden
 * Extract the DID from an Identity, or return the DID of the signing Identity if no Identity is passed
 */
export declare function getDid(value: string | Identity | undefined, context: Context): Promise<string>;
/**
 * @hidden
 * Given a DID return the corresponding Identity, given an Identity return the Identity
 */
export declare function asIdentity(value: string | Identity, context: Context): Identity;
/**
 * @hidden
 * DID | Identity -> DID
 */
export declare function asDid(value: string | Identity): string;
/**
 * @hidden
 * Given an Identity, return the Identity, given a DID returns the corresponding Identity, if value is falsy, then return currentIdentity
 */
export declare function getIdentity(value: string | Identity | undefined, context: Context): Promise<Identity>;
/**
 * @hidden
 */
export declare function createClaim(claimType: string, jurisdiction: Falsyable<string>, middlewareScope: Falsyable<MiddlewareScope>, cddId: Falsyable<string>, scopeId: Falsyable<string>): Claim;
/**
 * @hidden
 *
 * Unwrap a Post Transaction Value
 */
export declare function unwrapValue<T>(value: MaybePostTransactionValue<T>): T;
/**
 * @hidden
 *
 * Unwrap all Post Transaction Values present in a tuple
 */
export declare function unwrapValues<T extends unknown[]>(values: MapMaybePostTransactionValue<T>): T;
/**
 * @hidden
 */
declare type EventData<Event> = Event extends AugmentedEvent<'promise', infer Data> ? Data : never;
/**
 * @hidden
 * Find every occurrence of a specific event inside a receipt
 *
 * @throws If the event is not found
 */
export declare function filterEventRecords<ModuleName extends keyof Events, EventName extends keyof Events[ModuleName]>(receipt: ISubmittableResult, mod: ModuleName, eventName: EventName): IEvent<EventData<Events[ModuleName][EventName]>>[];
/**
 * @hidden
 */
export declare function padString(value: string, length: number): string;
/**
 * @hidden
 */
export declare function removePadding(value: string): string;
/**
 * @hidden
 *
 * Return whether the string is fully printable ASCII
 */
export declare function isPrintableAscii(value: string): boolean;
/**
 * @hidden
 *
 * Makes an entries request to the chain. If pagination options are supplied,
 *  the request will be paginated. Otherwise, all entries will be requested at once
 */
export declare function requestPaginated<F extends AnyFunction, T extends AnyTuple>(query: AugmentedQuery<'promise', F, T> | AugmentedQueryDoubleMap<'promise', F, T>, opts: {
    paginationOpts?: PaginationOptions;
    arg?: Parameters<F>[0];
}): Promise<{
    entries: [StorageKey<T>, ObsInnerType<ReturnType<F>>][];
    lastKey: NextKey;
}>;
/**
 * @hidden
 *
 * Makes a request to the chain. If a block hash is supplied,
 *   the request will be made at that block. Otherwise, the most recent block will be queried
 */
export declare function requestAtBlock<F extends AnyFunction>(query: AugmentedQuery<'promise', F> | AugmentedQueryDoubleMap<'promise', F>, opts: {
    blockHash?: string | BlockHash;
    args: Parameters<F>;
}, context: Context): Promise<ObsInnerType<ReturnType<F>>>;
/**
 * @hidden
 *
 * Calculates next page number for paginated GraphQL ResultSet.
 * Returns null if there is no next page.
 *
 * @param size - page size requested
 * @param start - start index requested
 * @param totalCount - total amount of elements returned by query
 *
 * @hidden
 *
 */
export declare function calculateNextKey(totalCount: BigNumber, size?: BigNumber, start?: BigNumber): NextKey;
/**
 * Create a method that prepares a procedure
 */
export declare function createProcedureMethod<ProcedureArgs, ProcedureReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: () => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    voidArgs: true;
}, context: Context): NoArgsProcedureMethod<ProcedureReturnValue, ProcedureReturnValue>;
export declare function createProcedureMethod<ProcedureArgs, ProcedureReturnValue, ReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: () => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    voidArgs: true;
    transformer: (value: ProcedureReturnValue) => ReturnValue | Promise<ReturnValue>;
}, context: Context): NoArgsProcedureMethod<ProcedureReturnValue, ReturnValue>;
export declare function createProcedureMethod<MethodArgs extends {}, ProcedureArgs, ProcedureReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
}, context: Context): ProcedureMethod<MethodArgs, ProcedureReturnValue, ProcedureReturnValue>;
export declare function createProcedureMethod<MethodArgs extends {}, ProcedureArgs, ProcedureReturnValue, ReturnValue, Storage = Record<string, unknown>>(args: {
    getProcedureAndArgs: (methodArgs: MethodArgs) => [
        (UnionOfProcedureFuncs<ProcedureArgs, ProcedureReturnValue, Storage> | ProcedureFunc<ProcedureArgs, ProcedureReturnValue, Storage>),
        ProcedureArgs
    ];
    transformer: (value: ProcedureReturnValue) => ReturnValue | Promise<ReturnValue>;
}, context: Context): ProcedureMethod<MethodArgs, ProcedureReturnValue, ReturnValue>;
/**
 * @hidden
 */
export declare function assertIsInteger(value: BigNumber): void;
/**
 * @hidden
 */
export declare function assertIsPositive(value: BigNumber): void;
/**
 * @hidden
 */
export declare function assertAddressValid(address: string, ss58Format: BigNumber): void;
/**
 * @hidden
 */
export declare function asTicker(asset: string | Asset): string;
/**
 * @hidden
 */
export declare function asAsset(asset: string | Asset, context: Context): Asset;
/**
 * @hidden
 */
export declare function xor(a: boolean, b: boolean): boolean;
/**
 * @hidden
 * Calculate the numeric complexity of a calendar period
 */
export declare function periodComplexity(period: CalendarPeriod): BigNumber;
/**
 * @hidden
 * Transform a conversion util into a version that returns null if the input is falsy
 */
export declare function optionize<InputType, OutputType, RestType extends unknown[]>(converter: (input: InputType, ...rest: RestType) => OutputType): (val: InputType | null | undefined, ...rest: RestType) => OutputType | null;
/**
 * @hidden
 * Compare two tags/modules and return true if they are equal, or if one is the other one's module
 */
export declare function isModuleOrTagMatch(a: TxTag | ModuleName, b: TxTag | ModuleName): boolean;
/**
 * @hidden
 *
 * Recursively convert a value into a human readable (JSON compliant) version:
 *   - Entities are converted via their `.toJson` method
 *   - Dates are converted to ISO strings
 *   - BigNumbers are converted to numerical strings
 */
export declare function toHumanReadable<T>(obj: T): HumanReadableType<T>;
/**
 * @hidden
 *
 * Return whether the two arrays have same elements.
 * It uses a `comparator` function to check if elements are equal.
 * If no comparator function is provided, it uses `isEqual` function of `lodash`
 */
export declare function hasSameElements<T>(first: T[], second: T[], comparator?: (a: T, b: T) => boolean): boolean;
/**
 * @hidden
 *
 * Perform a deep comparison between two compliance conditions
 */
export declare function conditionsAreEqual(a: Condition | InputCondition, b: Condition | InputCondition): boolean;
/**
 * @hidden
 *
 * Transforms `InputCACheckpoint` values to `Checkpoint | CheckpointSchedule | Date` for easier processing
 */
export declare function getCheckpointValue(checkpoint: InputCaCheckpoint, asset: string | Asset, context: Context): Promise<Checkpoint | CheckpointSchedule | Date>;
interface TxAndArgsArray<Args extends unknown[] = unknown[]> {
    transaction: PolymeshTx<Args>;
    argsArray: Args[];
}
declare type MapTxAndArgsArray<Args extends unknown[][]> = {
    [K in keyof Args]: Args[K] extends unknown[] ? TxAndArgsArray<Args[K]> : never;
};
/**
 * Assemble the `transactions` array that has to be passed to `addBatchTransaction` from a set of parameter arrays with their
 *   respective transaction
 */
export declare function assembleBatchTransactions<ArgsArray extends unknown[][]>(txsAndArgs: MapTxAndArgsArray<ArgsArray>): MapTxWithArgs<unknown[][]>;
/**
 * @hidden
 *
 * Returns portfolio numbers for a set of portfolio names
 */
export declare function getPortfolioIdsByName(rawIdentityId: IdentityId, rawNames: PortfolioName[], context: Context): Promise<(BigNumber | null)[]>;
/**
 * @hidden
 *
 * Check if a transaction matches the type of its args. Returns the same value but stripped of the types. This function has no logic, it's strictly
 *   for type safety around `addBatchTransaction`
 */
export declare function checkTxType<Args extends unknown[]>(tx: TxWithArgs<Args>): TxWithArgs<unknown[]>;
/**
 * @hidden
 *
 * Add an empty handler to a promise to avoid false positive unhandled promise errors. The original promise
 *   is returned, so rejections are still bubbled up and caught properly. This is an ugly hack and should be used
 *   sparingly and only if you KNOW that rejections will be handled properly down the line
 *
 * More info:
 *
 * - https://github.com/facebook/jest/issues/6028#issuecomment-567851031
 * - https://stackoverflow.com/questions/59060508/how-to-handle-an-unhandled-promise-rejection-asynchronously
 * - https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505#40921505
 */
export declare function defusePromise<T>(promise: Promise<T>): Promise<T>;
/**
 * @hidden
 *
 * Transform an array of Identities into exempted IDs for Transfer Managers. If the asset requires
 *   investor uniqueness, Scope IDs are fetched and returned. Otherwise, we use Identity IDs
 *
 * @note fetches missing scope IDs from the chain
 * @note even though the signature for `addExemptedEntities` requires `ScopeId`s as parameters,
 *   it accepts and handles `IdentityId` parameters as well. Nothing special has to be done typing-wise since they're both aliases
 *   for `U8aFixed`
 *
 * @throws
 *   - if the Asset requires Investor Uniqueness and one or more of the passed Identities don't have Scope IDs
 *   - if there are duplicated Identities/ScopeIDs
 */
export declare function getExemptedIds(identities: (string | Identity)[], context: Context, ticker: string): Promise<string[]>;
/**
 * @hidden
 *
 * Checks chain version. This function uses a websocket as it's intended to be called during initialization
 * @param nodeUrl - URL for the chain node
 * @returns A promise that resolves if the version is in the expected range, otherwise it will reject
 */
export declare function assertExpectedChainVersion(nodeUrl: string): Promise<void>;
//# sourceMappingURL=internal.d.ts.map